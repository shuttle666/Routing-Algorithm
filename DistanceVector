#!/usr/bin/env python3
import sys

class Neighbor:
    def __init__(self, neighbor, cost):
        self.neighbor = neighbor
        self.cost = cost

class Graph:
    def __init__(self):
        self.net = {}

    def add_node(self, node):
        if node not in self.net:
            self.net[node] = []

    def add_edge(self, source, neighbor, weight):
        if weight != -1:
            self.add_node(source)
            self.add_node(neighbor)
            self.net[source] = [n for n in self.net[source] if n.neighbor != neighbor]
            self.net[neighbor] = [n for n in self.net[neighbor] if n.neighbor != source]
            self.net[source].append(Neighbor(neighbor, weight))
            self.net[neighbor].append(Neighbor(source, weight))

    def update_edge(self, source, neighbor, weight):
        if weight == -1:
            if source in self.net:
                self.net[source] = [n for n in self.net[source] if n.neighbor != neighbor]
            if neighbor in self.net:
                self.net[neighbor] = [n for n in self.net[neighbor] if n.neighbor != source]
            if source in self.net and len(self.net[source]) == 0:
                del self.net[source]
            if neighbor in self.net and len(self.net[neighbor]) == 0:
                del self.net[neighbor]
        else:
            self.add_edge(source, neighbor, weight)

def print_distance_table(routers, distance_tables, t):
    for router in routers:
        print(f"Distance Table of router {router} at t={t}:")
        destinations = [r for r in routers if r != router]
        if destinations:
            print("    ", end="")
            for dest in destinations:
                print(f"{dest:5}", end="")
            print()
            for dest in destinations:
                print(f"{dest:5}", end="")
                for via in destinations:
                    cost = distance_tables[router].get((dest, via), float('inf'))
                    cost_str = str(int(cost)) if cost != float('inf') else "INF"
                    print(f"{cost_str:5}", end="")
                print()
        print()

def print_routing_table(routers, routing_tables):
    for router in routers:
        print(f"Routing Table of router {router}:")
        destinations = [r for r in routers if r != router]
        for dest in destinations:
            if dest in routing_tables[router]:
                next_hop, cost = routing_tables[router][dest]
                cost_str = str(int(cost)) if cost != float('inf') else "INF"
                next_hop_str = next_hop if next_hop else "INF"
                print(f"{dest},{next_hop_str},{cost_str}")
            else:
                print(f"{dest},INF,INF")
        print()

def merge_tables(old_distance_tables, old_routing_tables, new_routers):
    new_distance_tables = {r: {} for r in new_routers}
    new_routing_tables = {r: {} for r in new_routers}
    for r in old_distance_tables:
        if r in new_routers:
            new_distance_tables[r] = old_distance_tables[r].copy()
            new_routing_tables[r] = old_routing_tables[r].copy()
    return new_distance_tables, new_routing_tables

def distance_vector_algorithm(net, start_t=0, old_distance_tables=None, old_routing_tables=None):
    routers = sorted(net.net.keys())
    if not routers:
        return None, None
    
    # Initialize tables
    distance_tables = {router: {} for router in routers}
    routing_tables = {router: {} for router in routers}
    
    # Merge old tables if provided
    if old_distance_tables and old_routing_tables:
        distance_tables, routing_tables = merge_tables(old_distance_tables, old_routing_tables, routers)
    
    # Initialize with direct neighbor costs
    for router in routers:
        neighbors = {n.neighbor: n.cost for n in net.net[router]}
        for dest in routers:
            if dest != router:
                if dest in neighbors:
                    routing_tables[router][dest] = (dest, neighbors[dest])
                for via in routers:
                    if via != router:
                        if via in neighbors:
                            if dest == via:
                                distance_tables[router][(dest, via)] = neighbors[via]
                            else:
                                distance_tables[router][(dest, via)] = float('inf')
                        else:
                            distance_tables[router][(dest, via)] = float('inf')
    
    # Initial distance vector exchange
    new_distance_tables = {router: {} for router in routers}
    for router in routers:
        neighbors = {n.neighbor: n.cost for n in net.net[router]}
        for dest in routers:
            if dest != router:
                min_cost = float('inf')
                best_via = None
                for via in routers:
                    if via != router:
                        if via in neighbors:
                            if dest == via:
                                new_distance_tables[router][(dest, via)] = neighbors[via]
                                if neighbors[via] < min_cost:
                                    min_cost = neighbors[via]
                                    best_via = via
                            else:
                                direct_cost = neighbors[via]
                                via_cost = float('inf')
                                if dest in routing_tables[via]:
                                    via_cost = routing_tables[via][dest][1]
                                total_cost = direct_cost + via_cost if via_cost != float('inf') else float('inf')
                                new_distance_tables[router][(dest, via)] = total_cost
                                if total_cost < min_cost:
                                    min_cost = total_cost
                                    best_via = via
                        else:
                            new_distance_tables[router][(dest, via)] = float('inf')
                if best_via and min_cost != float('inf'):
                    routing_tables[router][dest] = (best_via, min_cost)
                elif dest not in routing_tables[router]:
                    routing_tables[router][dest] = (None, float('inf'))
    distance_tables = new_distance_tables
    
    t = start_t
    max_iterations = 100
    
    while t < max_iterations:
        print_distance_table(routers, distance_tables, t)
        
        new_distance_tables = {router: {} for router in routers}
        changed_count = 0
        total_slots = len(routers) * (len(routers) - 1) * (len(routers) - 1)
        
        for router in routers:
            neighbors = {n.neighbor: n.cost for n in net.net[router]}
            for dest in routers:
                if dest != router:
                    min_cost = float('inf')
                    best_via = None
                    for via in routers:
                        if via != router:
                            if via in neighbors:
                                if dest == via:
                                    new_distance_tables[router][(dest, via)] = neighbors[via]
                                    if neighbors[via] < min_cost:
                                        min_cost = neighbors[via]
                                        best_via = via
                                else:
                                    direct_cost = neighbors[via]
                                    via_cost = float('inf')
                                    if dest in routing_tables[via]:
                                        via_cost = routing_tables[via][dest][1]
                                    total_cost = direct_cost + via_cost if via_cost != float('inf') else float('inf')
                                    new_distance_tables[router][(dest, via)] = total_cost
                                    if total_cost < min_cost:
                                        min_cost = total_cost
                                        best_via = via
                            else:
                                new_distance_tables[router][(dest, via)] = float('inf')
                            old_cost = distance_tables[router].get((dest, via), float('inf'))
                            new_cost = new_distance_tables[router][(dest, via)]
                            if old_cost == new_cost:
                                changed_count += 1
                    if best_via and min_cost != float('inf'):
                        routing_tables[router][dest] = (best_via, min_cost)
                    elif dest not in routing_tables[router]:
                        routing_tables[router][dest] = (None, float('inf'))
        
        distance_tables = new_distance_tables
        if changed_count == total_slots:
            break
        t += 1
    
    print_routing_table(routers, routing_tables)
    return distance_tables, routing_tables

def main():
    try:
        net = Graph()
        
        while True:
            line = sys.stdin.readline().strip()
            if not line:
                break
            if line == "START":
                break
            net.add_node(line)
        
        while True:
            line = sys.stdin.readline().strip()
            if not line:
                break
            if line == "UPDATE":
                break
            parts = line.split()
            if len(parts) == 3:
                source, neighbor, weight = parts
                weight = int(weight)
                net.add_edge(source, neighbor, weight)
        
        distance_tables = None
        routing_tables = None
        if net.net:
            distance_tables, routing_tables = distance_vector_algorithm(net, start_t=0)
        
        updates = []
        while True:
            line = sys.stdin.readline().strip()
            if not line or line == "END":
                break
            parts = line.split()
            if len(parts) == 3:
                source, neighbor, weight = parts
                updates.append((source, neighbor, int(weight)))
        
        if updates:
            for source, neighbor, weight in updates:
                net.update_edge(source, neighbor, weight)
            print("Updated topology:")
            for router in sorted(net.net.keys()):
                neighbors = [(n.neighbor, n.cost) for n in net.net[router]]
                print(f"{router}: {neighbors}")
            if net.net:
                distance_vector_algorithm(net, start_t=3, old_distance_tables=distance_tables, old_routing_tables=routing_tables)
    
    except Exception as e:
        sys.stderr.write(f"Error: {str(e)}\n")
        return

if __name__ == "__main__":
    main()