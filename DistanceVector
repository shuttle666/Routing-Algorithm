#!/usr/bin/env python3
import sys

class Neighbor:
    def __init__(self, neighbor, cost):
        self.neighbor = neighbor
        self.cost = cost

class Graph:
    def __init__(self):
        self.net = {}

    def add_node(self, node):
        if node not in self.net:
            self.net[node] = []

    def add_edge(self, source, neighbor, weight):
        if weight != -1:
            self.add_node(source)
            self.add_node(neighbor)
            # Remove existing edge if any
            self.net[source] = [n for n in self.net[source] if n.neighbor != neighbor]
            self.net[neighbor] = [n for n in self.net[neighbor] if n.neighbor != source]
            # Add new edge
            self.net[source].append(Neighbor(neighbor, weight))
            self.net[neighbor].append(Neighbor(source, weight))

    def update_edge(self, source, neighbor, weight):
        if weight == -1:
            # Remove edge
            if source in self.net:
                self.net[source] = [n for n in self.net[source] if n.neighbor != neighbor]
            if neighbor in self.net:
                self.net[neighbor] = [n for n in self.net[neighbor] if n.neighbor != source]
            # Remove isolated nodes
            if source in self.net and len(self.net[source]) == 0:
                del self.net[source]
            if neighbor in self.net and len(self.net[neighbor]) == 0:
                del self.net[neighbor]
        else:
            self.add_edge(source, neighbor, weight)

def print_distance_table(routers, distance_tables, t):
    for router in routers:
        print(f"Distance Table of router {router} at t={t}:")
        destinations = [r for r in routers if r != router]
        if destinations:
            # Print header
            print("    ", end="")
            for dest in destinations:
                print(f"{dest:5}", end="")
            print()
            
            # Print rows
            for via in destinations:
                print(f"{via:5}", end="")
                for dest in destinations:
                    cost = distance_tables[router].get((dest, via), float('inf'))
                    cost_str = str(int(cost)) if cost != float('inf') else "INF"
                    print(f"{cost_str:5}", end="")
                print()
        print()

def print_routing_table(routers, routing_tables):
    for router in routers:
        print(f"Routing Table of router {router}:")
        destinations = [r for r in routers if r != router]
        for dest in destinations:
            if dest in routing_tables[router]:
                next_hop, cost = routing_tables[router][dest]
                cost_str = str(int(cost)) if cost != float('inf') else "INF"
                next_hop_str = next_hop if next_hop else "INF"
                print(f"{dest},{next_hop_str},{cost_str}")
            else:
                print(f"{dest},INF,INF")
        print()

def merge_tables(old_distance_tables, old_routing_tables, new_routers):
    new_distance_tables = {r: {} for r in new_routers}
    new_routing_tables = {r: {} for r in new_routers}
    for r in old_distance_tables:
        if r in new_routers:
            new_distance_tables[r] = old_distance_tables[r].copy()
            new_routing_tables[r] = old_routing_tables[r].copy()
    return new_distance_tables, new_routing_tables

def distance_vector_algorithm(net, start_t=0, old_distance_tables=None, old_routing_tables=None):
    routers = sorted(net.net.keys())
    if not routers:
        return None, None
    
    # Initialize tables
    distance_tables = {router: {} for router in routers}
    routing_tables = {router: {} for router in routers}
    
    # Merge old tables if provided
    if old_distance_tables and old_routing_tables:
        distance_tables, routing_tables = merge_tables(old_distance_tables, old_routing_tables, routers)
    
    # Initialize distance tables with direct costs
    for router in routers:
        neighbors = {n.neighbor: n.cost for n in net.net[router]}
        for dest in routers:
            if dest != router:
                for via in routers:
                    if via != router:
                        if via in neighbors:
                            if dest == via:
                                # Direct connection
                                distance_tables[router][(dest, via)] = neighbors[via]
                            else:
                                # No path via this neighbor initially
                                distance_tables[router][(dest, via)] = float('inf')
                        else:
                            # No connection to this via node
                            distance_tables[router][(dest, via)] = float('inf')
    
    t = start_t
    max_iterations = 100
    
    while t < max_iterations:
        print_distance_table(routers, distance_tables, t)
        
        new_distance_tables = {router: {} for router in routers}
        changed = False
        
        # Calculate new distance tables using Bellman-Ford equation
        for router in routers:
            neighbors = {n.neighbor: n.cost for n in net.net[router]}
            for dest in routers:
                if dest != router:
                    for via in routers:
                        if via != router:
                            if via in neighbors:
                                if dest == via:
                                    # Direct path
                                    new_distance_tables[router][(dest, via)] = neighbors[via]
                                else:
                                    # Path via intermediate node
                                    direct_cost = neighbors[via]
                                    via_to_dest_cost = float('inf')
                                    
                                    # Find minimum cost from via to dest
                                    for next_hop in routers:
                                        if next_hop != via:
                                            cost = distance_tables[via].get((dest, next_hop), float('inf'))
                                            if cost < via_to_dest_cost:
                                                via_to_dest_cost = cost
                                    
                                    if via_to_dest_cost != float('inf'):
                                        new_distance_tables[router][(dest, via)] = direct_cost + via_to_dest_cost
                                    else:
                                        new_distance_tables[router][(dest, via)] = float('inf')
                            else:
                                # No connection to via node
                                new_distance_tables[router][(dest, via)] = float('inf')
                            
                            # Check for changes
                            old_cost = distance_tables[router].get((dest, via), float('inf'))
                            new_cost = new_distance_tables[router][(dest, via)]
                            if old_cost != new_cost:
                                changed = True
        
        # Update distance tables
        distance_tables = new_distance_tables
        
        # Update routing tables
        for router in routers:
            for dest in routers:
                if dest != router:
                    min_cost = float('inf')
                    best_via = None
                    for via in routers:
                        if via != router:
                            cost = distance_tables[router].get((dest, via), float('inf'))
                            if cost < min_cost:
                                min_cost = cost
                                best_via = via
                            elif cost == min_cost and best_via and via < best_via:
                                # Choose alphabetically first in case of tie
                                best_via = via
                    
                    if best_via and min_cost != float('inf'):
                        routing_tables[router][dest] = (best_via, min_cost)
                    else:
                        routing_tables[router][dest] = (None, float('inf'))
        
        # Check for convergence
        if not changed:
            break
        t += 1
    
    print_routing_table(routers, routing_tables)
    return distance_tables, routing_tables

def main():
    try:
        net = Graph()
        
        # Read router names
        while True:
            line = sys.stdin.readline().strip()
            if not line:
                break
            if line == "START":
                break
            net.add_node(line)
        
        # Read initial topology
        while True:
            line = sys.stdin.readline().strip()
            if not line:
                break
            if line == "UPDATE":
                break
            parts = line.split()
            if len(parts) == 3:
                source, neighbor, weight = parts
                weight = int(weight)
                net.add_edge(source, neighbor, weight)
        
        # Run initial algorithm
        distance_tables = None
        routing_tables = None
        if net.net:
            distance_tables, routing_tables = distance_vector_algorithm(net, start_t=0)
        
        # Read updates
        updates = []
        while True:
            line = sys.stdin.readline().strip()
            if not line or line == "END":
                break
            parts = line.split()
            if len(parts) == 3:
                source, neighbor, weight = parts
                updates.append((source, neighbor, int(weight)))
        
        # Apply updates and run algorithm again
        if updates:
            for source, neighbor, weight in updates:
                net.update_edge(source, neighbor, weight)
            if net.net:
                distance_vector_algorithm(net, start_t=3, old_distance_tables=distance_tables, old_routing_tables=routing_tables)
    
    except Exception as e:
        sys.stderr.write(f"Error: {str(e)}\n")
        return

if __name__ == "__main__":
    main()